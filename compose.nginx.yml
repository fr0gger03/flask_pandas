# Production Docker Compose with Nginx for Large File Uploads
# This configuration supports up to 10GB file uploads with optimized performance

services:
  # Postgres Service
  db:
    image: postgres:17.4
    ports:
      - 5432:${DATABASE_PORT}
    networks:
      - app_network_prod
    volumes:
      - ./parser/sql:/docker-entrypoint-initdb.d
      - db-data:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    restart: always
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "inventorydbuser", "-d", "inventorydb"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Flask Application with Gunicorn
  app:
    build:
      context: .
      dockerfile: Dockerfile.production
    container_name: workload_parser_app_nginx
    environment:
      # Flask configuration
      - FLASK_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - SECRET_KEY=${SECRET_KEY}
      - UPLOAD_FOLDER=${UPLOAD_FOLDER}
      # Security settings
      - WTF_CSRF_ENABLED=true
      - WTF_CSRF_TIME_LIMIT=3600
      # File upload limits - 10GB for large datasets
      - MAX_CONTENT_LENGTH=10737418240  # 10GB
    volumes:
      # Persistent storage for uploaded files and logs
      - app_input_nginx:/app/parser/input
      - app_logs_nginx:/app/logs
      # Shared volume for temporary upload storage
      - nginx_upload_temp:/tmp/nginx_upload
    networks:
      - app_network_nginx
    depends_on:
      db:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    # Increased resource limits for large file processing
    deploy:
      resources:
        limits:
          memory: 4G
          cpus: '2.0'
        reservations:
          memory: 1G
          cpus: '1.0'

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: workload_parser_nginx
    ports:
      - "80:80"
      - "443:443"  # For future HTTPS support
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - nginx_logs:/var/log/nginx
      - nginx_upload_temp:/tmp/nginx_upload
      # Mount static files if you have any
      # - app_static:/app/parser/static:ro
    networks:
      - app_network_nginx
    depends_on:
      - app
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    # Create upload temp directory with proper permissions
    command: >
      sh -c "mkdir -p /tmp/nginx_upload &&
             chmod 777 /tmp/nginx_upload &&
             nginx -g 'daemon off;'"

  # Redis for session storage (optional but recommended for production)
  redis:
    image: redis:7-alpine
    container_name: workload_parser_redis
    networks:
      - app_network_nginx
    restart: unless-stopped
    volumes:
      - redis_data_nginx:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
    profiles:
      - with-redis  # Optional service

volumes:
  # Persistent data volumes
  postgres_data_nginx:
    driver: local
  app_input_nginx:
    driver: local
  app_logs_nginx:
    driver: local
  nginx_logs:
    driver: local
  nginx_upload_temp:
    driver: local
  redis_data_nginx:
    driver: local

networks:
  app_network_nginx:
    driver: bridge

